import {expect} from 'chai';

import rewiremock, {addPlugin} from '../src/index';

import nodePlugin from '../src/plugins/nodejs';
import relativePlugin from '../src/plugins/relative';
import aliasPlugin, {configure as configureWebpackAlias} from '../src/plugins/webpack-alias';

describe('rewiremock ', () => {
  describe('overloads ', () => {
    it('should not overload: ', () => {
      rewiremock('./lib/a/foo')
        .with(() => 'aa');

      rewiremock('./lib/a/../b/bar')
        .with(() => 'bb');

      rewiremock('./lib/a/../b/baz')
        .with(() => 'cc');

      const unmockedBaz = require('./lib/a/test.js');
      expect(unmockedBaz()).to.be.equal('foobarbaz');

      rewiremock.enable();

      const mockedBaz = require('./lib/a/test.js');
      expect(mockedBaz()).to.be.equal('foobarbaz');
      rewiremock.disable();
    });

    it('should overload with node plugin: ', () => {
      rewiremock.inScope(() => {
        addPlugin(nodePlugin);
        rewiremock('./lib/a/foo')
          .with(() => 'aa');

        rewiremock('./lib/a/../b/bar')
          .with(() => 'bb');

        rewiremock('./lib/a/../b/baz')
          .with(() => 'cc');

        const unmockedBaz = require('./lib/a/test.js');
        expect(unmockedBaz()).to.be.equal('foobarbaz');

        rewiremock.enable();

        const mockedBaz = require('./lib/a/test.js');
        expect(mockedBaz()).to.be.equal('aabbcc');
        rewiremock.disable();
      });
    });

    it('should overload with relative plugin: ', () => {
      rewiremock.inScope(() => {
        addPlugin(relativePlugin);
        rewiremock('./foo')
          .with(() => 'aa');

        rewiremock('../b/bar')
          .with(() => 'bb');

        rewiremock('../b/baz')
          .with(() => 'cc');

        const unmockedBaz = require('./lib/a/test.js');
        expect(unmockedBaz()).to.be.equal('foobarbaz');

        rewiremock.enable();

        const mockedBaz = require('./lib/a/test.js');
        expect(mockedBaz()).to.be.equal('aabbcc');
        rewiremock.disable();
      });
    });

    it('should overload with webpack alias plugin: ', () => {
      rewiremock.inScope(() => {
        configureWebpackAlias('_tests/webpack.config.js');

        addPlugin(aliasPlugin);
        rewiremock('my-absolute-test-lib/foo')
          .with(() => 'aa');

        rewiremock('same-folder-lib/bar')
          .with(() => 'bb');

        rewiremock('../b/baz')
          .with(() => 'cc');

        const unmockedBaz = require('./lib/a/test.js');
        expect(unmockedBaz()).to.be.equal('foobarbaz');

        rewiremock.enable();

        const mockedBaz = require('./lib/a/test.js');
        expect(mockedBaz()).to.be.equal('aabbcc');
        rewiremock.disable();
      });
    });
  });

  describe('mocking ', () => {
    it('should replace one module by another: ', () => {
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);
          rewiremock('./foo').by('./foo2');
        })
        .then(mocked => expect(mocked()).to.be.equal('FOObarbaz'));
    });

    it('should replace one module by autogenerated one: ', () => {
      let toched = false;
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);

          rewiremock('./foo').by(({name}) => {
            toched = name;
            return () => "FOO";
          });
          expect(toched).to.be.false;
        })
        .then(mocked => {
          expect(mocked()).to.be.equal('FOObarbaz');
        });
    });

    it('should replace one module by autogenerated one with callThougth: ', () => {
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);

          rewiremock('./foo')
            .callThrough()
            .by(({original}) => {
              return () => "~" + original() + '~'
            });
        })
        .then(mocked => expect(mocked()).to.be.equal('~foo~barbaz'));
    });

    it('should replace one module by autogenerated one with requireActual: ', () => {
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);

          rewiremock('./foo')
            .by(({requireActual}) => {
              return () => "~" + requireActual('./foo.js')() + '~'
            });
        })
        .then(mocked => expect(mocked()).to.be.equal('~foo~barbaz'));
    });
  });

  describe('direct child ', () => {
    it('should mock any level entity: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          rewiremock('./baz')
            .with(() => 'mock');
        })
        .then(mocked => expect(mocked()).to.be.equal('>+mockmock'));
    });

    it('should mock top level entity only: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock('./baz')
            .with(() => 'mock')
            .directChildOnly();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+!mock'));
    });
  });

  describe('called from a mock ', () => {
    it('should mock top level entity only due to mocked parent: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock('./baz')
            .with(() => 'mock')
            .calledFromMock();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+!mock'));
    });

    it('should mock all due to callThrough mocked : ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock('./baz')
            .with(() => 'mock')
            .calledFromMock();
          rewiremock('./bar')
            .callThrough();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+mockmock'));
    });
  });

});
